/*
 * Copyright 2021 Tomasz Pa≈∫dziurek <t.pazdziurek@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package com.tp.tools.function;

import static lombok.AccessLevel.PRIVATE;

import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

/**
 * This is an inclusive-or type that can hold either left, or right or both values.
 * It's right biased, so whenever an operation doesn't refer to a member explicitly,
 * it operates on the right member.
 * <p>
 * Operations are lazily evaluated, thus no methods are executed until one of terminal methods is
 * called. Terminal operations are:
 * <ul>
 *   <li>{@link Ior#memoized()}</li>
 *   <li>{@link Ior#fold(Function, Function, BiFunction)}</li>
 *   <li>{@link Ior#get()}</li>
 *   <li>{@link Ior#getLeft()}</li>
 *   <li>{@link Ior#getOrElse(Function)}</li>
 *   <li>{@link Ior#getLeftOrElse(Function)}</li>
 *   <li>{@link Ior#getOrElse(Object)}</li>
 *   <li>{@link Ior#getLeftOrElse(Object)}</li>
 *   <li>{@link Ior#isRight()}</li>
 *   <li>{@link Ior#isLeft()}</li>
 *   <li>{@link Ior#isBoth()}</li>
 * </ul>
 * <p>
 *   <b>Gotchas</b>:
 *   <ul>
 *     <li>Calling any terminal function will execute the entire function chain, thus it's <b>strongly</b>
 *     advised to call {@link Ior#memoized()} function first, which will execute the entire function chain
 *     and return a new Ior instance with all values computed.</li>
 *   </ul>
 */
public abstract class Ior<L, R> {

  /**
   * Maps right value held by this {@link Ior} using the given <code>mapper</code> if this {@link
   * Ior} instance holds right value (is right or both instance).
   * Does nothing if this {@link Ior} is left instance.
   *
   * @param mapper mapper.
   * @param <V>    type returned by the <code>mapper</code>.
   * @return {@link Ior} with new right value mapped or this {@link Ior} when mapping did not occur.
   */
  public abstract <V> Ior<L, V> map(final Function<? super R, ? extends V> mapper);

  /**
   * Maps right value held by this {@link Ior} using the given <code>mapper</code> to new {@link
   * Ior} instance if this {@link Ior} instance holds right value (is right or both instance).
   * Does nothing if this {@link Ior} is left instance.
   *
   * @param mapper mapper.
   * @param <V>    type the new {@link Ior} instance holds as right.
   * @return new {@link Ior} generated by <code>mapper</code> or this {@link Ior} when mapping
   * did not occur.
   */
  public abstract <V> Ior<L, V> flatMap(final Function<? super R, ? extends Ior<L, V>> mapper);

  /**
   * Maps left value held by this {@link Ior} using the given <code>mapper</code> if this {@link
   * Ior} instance holds left value (is left or both instance).
   * Does nothing if this {@link Ior} is right instance.
   *
   * @param mapper mapper.
   * @param <K>    type returned by the <code>mapper</code>.
   * @return {@link Ior} with new left value mapped or this {@link Ior} when mapping did not occur.
   */
  public abstract <K> Ior<K, R> mapLeft(final Function<? super L, ? extends K> mapper,
      Combiner<K> combiner);

  /**
   * Maps left value held by this {@link Ior} using the given <code>mapper</code> if this {@link
   * Ior} instance holds left value (is left or both instance).
   * Does nothing if this {@link Ior} is right instance.
   *
   * @param mapper mapper.
   * @return {@link Ior} with new left value mapped or this {@link Ior} when mapping did not occur.
   */
  public abstract Ior<L, R> mapLeft(final Function<? super L, ? extends L> mapper);

  /**
   * Maps left value held by this {@link Ior} using the given <code>mapper</code> to new {@link
   * Ior} instance if this {@link Ior} instance holds left value (is left or both instance).
   * Does nothing if this {@link Ior} is right instance.
   *
   * @param mapper mapper.
   * @param <K>    type the new {@link Ior} instance holds as left.
   * @return new {@link Ior} generated by <code>mapper</code> or this {@link Ior} when mapping
   * did not occur.
   */
  public <K> Ior<K, R> flatMapLeft(
      final Function<? super L, ? extends Ior<K, R>> mapper) {
    if (isRight()) {
      @SuppressWarnings("unchecked") final Ior<K, R> that = (Ior<K, R>) this;
      return that;
    } else {
      return new IorLazy<>(nothing -> mapper.apply(getLeft()));
    }
  }

  /**
   * Maps this {@link Ior} to <code>U</code> value. Applies <code>leftMapper</code> on this {@link
   * Ior}'s left value if this {@link Ior} is left instance.
   * Applies <code>rightMapper</code> on this {@link Ior}'s right value if this {@link Ior}
   * is right instance.
   * Applies <code>bothMapper</code> on this {@link Ior}'s left and right values if this {@link Ior}
   * is both instance.
   *
   * @param leftMapper  left value mapper.
   * @param rightMapper right value mapper.
   * @param bothMapper  both values mapper.
   * @param <U>         returned type.
   * @return mapped value.
   */
  public <U> U fold(final Function<? super L, ? extends U> leftMapper,
      final Function<? super R, ? extends U> rightMapper,
      final BiFunction<? super L, ? super R, ? extends U> bothMapper) {
    if (isLeft()) {
      return leftMapper.apply(getLeft());
    } else if (isRight()) {
      return rightMapper.apply(get());
    } else {
      return bothMapper.apply(getLeft(), get());
    }
  }

  /**
   * Executes <code>consumer</code> on right value held by this {@link Ior} if it holds right
   * value (is right or both instance).
   * Does nothing if this {@link Ior} is left instance.
   *
   * @param consumer consumer.
   * @return {@link Ior} with <code>consumer</code> method added to execution chain.
   */
  public Ior<L, R> peek(final Consumer<? super R> consumer) {
    if (isLeft()) {
      return this;
    } else {
      return map(right -> {
        consumer.accept(right);
        return right;
      });
    }
  }

  /**
   * Executes <code>consumer</code> on left value held by this {@link Ior} if it holds left
   * value (is left or both instance).
   * Does nothing if this {@link Ior} is right instance.
   *
   * @param consumer consumer.
   * @return {@link Ior} with <code>consumer</code> method added to execution chain.
   */
  public abstract Ior<L, R> peekLeft(final Consumer<? super L> consumer);

  /**
   * Gets right value of this {@link Ior} if it holds right value or generates alternative value
   * based on <code>orElse</code> function execution on the left value.
   *
   * @param orElse left value mapper.
   * @return right value of this {@link Ior} if it holds right value or value generated by
   * <code>orElse</code> function, otherwise.
   */
  public R getOrElse(final Function<? super L, ? extends R> orElse) {
    return isLeft()
        ? orElse.apply(getLeft())
        : get();
  }

  /**
   * Gets right value of this {@link Ior} if it holds right value or returns alternative
   * <code>orElse</code> value.
   *
   * @param orElse alternative value.
   * @return right value of this {@link Ior} if it holds right value or <code>orElse</code>
   * value, otherwise.
   */
  public R getOrElse(final R orElse) {
    return isLeft() ? orElse : get();
  }

  /**
   * Gets left value of this {@link Ior} if it holds left value or generates alternative value
   * based on <code>orElse</code> function execution on the right value.
   *
   * @param orElse right value mapper.
   * @return left value of this {@link Ior} if it holds left value or value generated by
   * <code>orElse</code> function, otherwise.
   */
  public L getLeftOrElse(final Function<? super R, ? extends L> orElse) {
    return isRight()
        ? orElse.apply(get())
        : getLeft();
  }

  /**
   * Gets left value of this {@link Ior} if it holds left value or returns alternative
   * <code>orElse</code> value.
   *
   * @param orElse alternative value.
   * @return left value of this {@link Ior} if it holds left value or <code>orElse</code>
   * value, otherwise.
   */
  public L getLeftOrElse(final L orElse) {
    return isRight() ? orElse : getLeft();
  }

  /**
   * Swaps left and right types.
   *
   * @return {@link Ior} instance with swapped types.
   */
  public Ior<R, L> swap(final Combiner<R> combiner) {
    if (isRight()) {
      return Ior.left(this::get);
    } else if (isLeft()) {
      return Ior.right(this::getLeft);
    } else {
      return Ior.both((Supplier<R>) this::get, this::getLeft, combiner);
    }
  }

  /**
   * Adds left {@link Ior} value.
   *
   * @param left left value.
   * @param <K>  left value type.
   * @return {@link Ior} both instance.
   * @throws UnsupportedOperationException when this {@link Ior} already has left value (is left or
   *                                       both instance).
   */
  public <K> Ior<K, R> withLeft(final K left, final Combiner<K> combiner) {
    return withLeft((Supplier<K>) () -> left, combiner);
  }

  /**
   * Adds right {@link Ior} value.
   *
   * @param right right value.
   * @param <V>   right value type.
   * @return {@link Ior} both instance.
   * @throws UnsupportedOperationException when this {@link Ior} already has right value (is right
   *                                       or
   *                                       both instance).
   */
  public <V> Ior<L, V> withRight(final V right, final Combiner<L> combiner) {
    return withRight(() -> right, combiner);
  }

  /**
   * This method will execute the entire function chain and return a result {@link Ior} instance
   * with already computed values. Calling this before other terminal functions ensures function
   * chain will be evaluated only once.
   *
   * @return {@link Ior} instance with already evaluated function chain.
   */
  public abstract Ior<L, R> memoized();

  /**
   * Gets right value of this {@link Ior}.
   *
   * @return right value of this {@link Ior}.
   * @throws UnsupportedOperationException if this {@link Ior} does not hold right value.
   */
  public abstract R get();

  /**
   * Gets left value of this {@link Ior}.
   *
   * @return left value of this {@link Ior}.
   * @throws UnsupportedOperationException if this {@link Ior} does not hold left value.
   */
  public abstract L getLeft();

  /**
   * Informs whether this {@link Ior} is left instance.
   *
   * @return <code>true</code> if this {@link Ior} is left instance, <code>false</code> otherwise.
   */
  public abstract boolean isLeft();

  /**
   * Informs whether this {@link Ior} is right instance.
   *
   * @return <code>true</code> if this {@link Ior} is right instance, <code>false</code> otherwise.
   */
  public abstract boolean isRight();

  /**
   * Informs whether this {@link Ior} is both instance.
   *
   * @return <code>true</code> if this {@link Ior} is both instance, <code>false</code> otherwise.
   */
  public abstract boolean isBoth();

  /**
   * Adds left {@link Ior} value.
   *
   * @param left left value supplier.
   * @param <K>  left value type.
   * @return {@link Ior} both instance.
   * @throws UnsupportedOperationException when this {@link Ior} already has left value (is left or
   *                                       both instance).
   */
  public abstract <K> Ior<K, R> withLeft(Supplier<K> left, Combiner<K> combiner);

  /**
   * Adds right {@link Ior} value.
   *
   * @param right right value supplier.
   * @param <V>   right value type.
   * @return {@link Ior} both instance.
   * @throws UnsupportedOperationException when this {@link Ior} already has right value (is right
   *                                       or
   *                                       both instance).
   */
  public abstract <V> Ior<L, V> withRight(Supplier<V> right, Combiner<L> combiner);

  /**
   * Creates {@link Ior} right instance with value supplier.
   *
   * @param supplier value supplier.
   * @param <L>      left type.
   * @param <R>      right type.
   * @return {@link Ior} right instance with value supplier.
   */
  public static <L, R> Ior<L, R> right(final Supplier<R> supplier) {
    return new Right<>(supplier);
  }

  /**
   * Creates {@link Ior} right instance with given value.
   *
   * @param value value.
   * @param <L>   left type.
   * @param <R>   right type.
   * @return {@link Ior} right instance with given value.
   */
  public static <L, R> Ior<L, R> right(final R value) {
    return Ior.right(() -> value);
  }

  /**
   * Creates {@link Ior} left instance with value supplier.
   *
   * @param supplier value supplier.
   * @param <L>      left type.
   * @param <R>      right type.
   * @return {@link Ior} left instance with value supplier.
   */
  public static <L, R> Ior<L, R> left(final Supplier<L> supplier) {
    return new Left<>(supplier);
  }

  /**
   * Creates {@link Ior} left instance with given value.
   *
   * @param value value.
   * @param <L>   left type.
   * @param <R>   right type.
   * @return {@link Ior} left instance with given value.
   */
  public static <L, R> Ior<L, R> left(final L value) {
    return Ior.left(() -> value);
  }

  /**
   * Creates {@link Ior} both instance with given left and right values.
   *
   * @param left  left value.
   * @param right right value.
   * @param <L>   left type.
   * @param <R>   right type.
   * @return {@link Ior} left instance with given left and right values.
   */
  public static <L, R> Ior<L, R> both(final L left, final R right, final Combiner<L> combiner) {
    return Ior.both((Supplier<L>) () -> left, () -> right, combiner);
  }

  /**
   * Creates {@link Ior} both instance with given left and right values.
   *
   * @param left  left value.
   * @param right right value supplier.
   * @param <L>   left type.
   * @param <R>   right type.
   * @return {@link Ior} left instance with given left and right values.
   */
  public static <L, R> Ior<L, R> both(final L left, final Supplier<R> right,
      final Combiner<L> combiner) {
    return Ior.both((Supplier<L>) () -> left, right, combiner);
  }

  /**
   * Creates {@link Ior} both instance with given left and right values.
   *
   * @param left  left value supplier.
   * @param right right value.
   * @param <L>   left type.
   * @param <R>   right type.
   * @return {@link Ior} left instance with given left and right values.
   */
  public static <L, R> Ior<L, R> both(final Supplier<L> left, final R right,
      final Combiner<L> combiner) {
    return Ior.both(left, () -> right, combiner);
  }

  /**
   * Creates {@link Ior} both instance with given left and right values.
   *
   * @param left  left value supplier.
   * @param right right value supplier.
   * @param <L>   left type.
   * @param <R>   right type.
   * @return {@link Ior} left instance with given left and right values.
   */
  public static <L, R> Ior<L, R> both(final Supplier<L> left, final Supplier<R> right,
      final Combiner<L> combiner) {
    return new Both<>(left, right, combiner);
  }

  @RequiredArgsConstructor(access = PRIVATE)
  private static class Right<L, R> extends Ior<L, R> {

    @NonNull
    private final Supplier<R> right;

    @Override
    public <V> Ior<L, V> flatMap(final Function<? super R, ? extends Ior<L, V>> mapper) {
      return new IorLazy<>(nothing -> mapper.apply(get()));
    }

    @Override
    public <V> Ior<L, V> map(final Function<? super R, ? extends V> mapper) {
      return Ior.right(() -> mapper.apply(get()));
    }

    @Override
    public <K> Ior<K, R> mapLeft(final Function<? super L, ? extends K> mapper,
        final Combiner<K> combiner) {
      @SuppressWarnings("unchecked") final Ior<K, R> that = (Ior<K, R>) this;
      return that;
    }

    @Override
    public Ior<L, R> mapLeft(final Function<? super L, ? extends L> mapper) {
      return this;
    }

    @Override
    public Ior<L, R> peekLeft(final Consumer<? super L> consumer) {
      return this;
    }

    @Override
    public Ior<L, R> memoized() {
      return this;
    }

    @Override
    public R get() {
      return right.get();
    }

    @Override
    public L getLeft() {
      throw new UnsupportedOperationException("Cannot get left value from Ior.Right instance.");
    }

    @Override
    public boolean isLeft() {
      return false;
    }

    @Override
    public boolean isRight() {
      return true;
    }

    @Override
    public boolean isBoth() {
      return false;
    }

    @Override
    public <K> Ior<K, R> withLeft(final Supplier<K> left, final Combiner<K> combiner) {
      @SuppressWarnings("unchecked") final Ior<K, R> that = (Ior<K, R>) this;
      return Ior.both(left, that::get, combiner);
    }

    @Override
    public <V> Ior<L, V> withRight(final Supplier<V> right, final Combiner<L> combiner) {
      throw new UnsupportedOperationException("Cannot add Ior.Right to Ior.Right instance.");
    }
  }

  @RequiredArgsConstructor(access = PRIVATE)
  private static class Left<L, R> extends Ior<L, R> {

    @NonNull
    private final Supplier<L> left;

    @Override
    public <V> Ior<L, V> flatMap(final Function<? super R, ? extends Ior<L, V>> mapper) {
      @SuppressWarnings("unchecked") final Ior<L, V> that = (Ior<L, V>) this;
      return that;
    }

    @Override
    public <V> Ior<L, V> map(final Function<? super R, ? extends V> mapper) {
      @SuppressWarnings("unchecked") final Ior<L, V> that = (Ior<L, V>) this;
      return that;
    }

    @Override
    public <K> Ior<K, R> mapLeft(final Function<? super L, ? extends K> mapper,
        final Combiner<K> combiner) {
      return Ior.left(() -> mapper.apply(getLeft()));
    }

    @Override
    public Ior<L, R> mapLeft(final Function<? super L, ? extends L> mapper) {
      return Ior.left(() -> mapper.apply(getLeft()));
    }

    @Override
    public Ior<L, R> peekLeft(final Consumer<? super L> consumer) {
      return Ior.left(() -> {
        final var left = getLeft();
        consumer.accept(left);
        return left;
      });
    }

    @Override
    public Ior<L, R> memoized() {
      return this;
    }

    @Override
    public R get() {
      throw new UnsupportedOperationException("Cannot get right value from Ior.Left instance.");
    }

    @Override
    public L getLeft() {
      return left.get();
    }

    @Override
    public boolean isLeft() {
      return true;
    }

    @Override
    public boolean isRight() {
      return false;
    }

    @Override
    public boolean isBoth() {
      return false;
    }

    @Override
    public <K> Ior<K, R> withLeft(final Supplier<K> left, final Combiner<K> combiner) {
      throw new UnsupportedOperationException("Cannot add Ior.Left to Ior.Left instance.");
    }

    @Override
    public <V> Ior<L, V> withRight(final Supplier<V> right, final Combiner<L> combiner) {
      @SuppressWarnings("unchecked") final Ior<L, V> that = (Ior<L, V>) this;
      return Ior.both((Supplier<L>) that::getLeft, right, combiner);
    }
  }

  @RequiredArgsConstructor(access = PRIVATE)
  private static class Both<L, R> extends Ior<L, R> {

    private final Supplier<L> left;
    private final Supplier<R> right;
    private final Combiner<L> combiner;

    @Override
    public <V> Ior<L, V> flatMap(final Function<? super R, ? extends Ior<L, V>> mapper) {
      return new IorLazy<>(nothing -> {
        final Ior<L, V> that = mapper.apply(get());
        if (that.isLeft()) {
          return Ior.left(this.combiner.combine(getLeft(), that.getLeft()));
        } else if (that.isBoth()) {
          return Ior
              .both(
                  (Supplier<L>) () -> this.combiner.combine(getLeft(), that.getLeft()),
                  that::get,
                  this.combiner
              );
        } else {
          return Ior.both((Supplier<L>) this::getLeft, that::get, this.combiner);
        }
      });
    }

    @Override
    public <V> Ior<L, V> map(final Function<? super R, ? extends V> mapper) {
      return Ior.both((Supplier<L>) this::getLeft, () -> mapper.apply(get()), this.combiner);
    }

    @Override
    public <K> Ior<K, R> mapLeft(final Function<? super L, ? extends K> mapper,
        final Combiner<K> combiner) {
      return Ior.both((Supplier<K>) () -> mapper.apply(getLeft()), this::get, combiner);
    }

    @Override
    public Ior<L, R> mapLeft(final Function<? super L, ? extends L> mapper) {
      return Ior.both((Supplier<L>) () -> mapper.apply(getLeft()), this::get, this.combiner);
    }

    @Override
    public Ior<L, R> peekLeft(final Consumer<? super L> consumer) {
      return mapLeft(left -> {
            consumer.accept(left);
            return left;
          },
          this.combiner);
    }

    @Override
    public Ior<L, R> memoized() {
      return this;
    }

    @Override
    public R get() {
      return right.get();
    }

    @Override
    public L getLeft() {
      return left.get();
    }

    @Override
    public boolean isLeft() {
      return false;
    }

    @Override
    public boolean isRight() {
      return false;
    }

    @Override
    public boolean isBoth() {
      return true;
    }

    @Override
    public <K> Ior<K, R> withLeft(final Supplier<K> left, final Combiner<K> combiner) {
      throw new UnsupportedOperationException("Cannot add Ior.Left to Ior.Left instance.");
    }

    @Override
    public <V> Ior<L, V> withRight(final Supplier<V> right, final Combiner<L> combiner) {
      throw new UnsupportedOperationException("Cannot add Ior.Left to Ior.Left instance.");
    }
  }

  @RequiredArgsConstructor(access = PRIVATE)
  private static class IorLazy<L, R> extends Ior<L, R> {

    private final Function<Void, Ior<L, R>> function;

    @Override
    public Ior<L, R> memoized() {
      return function.apply(null);
    }

    @Override
    public R get() {
      return function.apply(null).get();
    }

    @Override
    public L getLeft() {
      return function.apply(null).getLeft();
    }

    @Override
    public boolean isLeft() {
      return function.apply(null).isLeft();
    }

    @Override
    public boolean isRight() {
      return function.apply(null).isRight();
    }

    @Override
    public boolean isBoth() {
      return function.apply(null).isBoth();
    }

    @Override
    public <K> Ior<K, R> withLeft(final Supplier<K> left, final Combiner<K> combiner) {
      return new IorLazy<>(this.function.andThen(ior -> ior.withLeft(left, combiner)));
    }

    @Override
    public <V> Ior<L, V> withRight(final Supplier<V> right, final Combiner<L> combiner) {
      return new IorLazy<>(this.function.andThen(ior -> ior.withRight(right, combiner)));
    }

    @Override
    public <V> Ior<L, V> map(final Function<? super R, ? extends V> mapper) {
      return new IorLazy<>(this.function.andThen(ior -> ior.map(mapper)));
    }

    @Override
    public <V> Ior<L, V> flatMap(final Function<? super R, ? extends Ior<L, V>> mapper) {
      return new IorLazy<>(this.function.andThen(ior -> ior.flatMap(mapper)));
    }

    @Override
    public <K> Ior<K, R> mapLeft(final Function<? super L, ? extends K> mapper,
        final Combiner<K> combiner) {
      return new IorLazy<>(this.function.andThen(ior -> ior.mapLeft(mapper, combiner)));
    }

    @Override
    public Ior<L, R> mapLeft(final Function<? super L, ? extends L> mapper) {
      return new IorLazy<>(this.function.andThen(ior -> ior.mapLeft(mapper)));
    }

    @Override
    public <K> Ior<K, R> flatMapLeft(final Function<? super L, ? extends Ior<K, R>> mapper) {
      return new IorLazy<>(this.function.andThen(ior -> ior.flatMapLeft(mapper)));
    }

    @Override
    public Ior<L, R> peek(final Consumer<? super R> consumer) {
      return new IorLazy<>(this.function.andThen(ior -> ior.peek(consumer)));
    }

    @Override
    public Ior<L, R> peekLeft(final Consumer<? super L> consumer) {
      return new IorLazy<>(this.function.andThen(ior -> ior.peekLeft(consumer)));
    }

    @Override
    public Ior<R, L> swap(final Combiner<R> combiner) {
      return new IorLazy<>(this.function.andThen(ior -> ior.swap(combiner)));
    }

    @Override
    public <U> U fold(final Function<? super L, ? extends U> leftMapper,
        final Function<? super R, ? extends U> rightMapper,
        final BiFunction<? super L, ? super R, ? extends U> bothMapper) {
      return this.function.apply(null).fold(leftMapper, rightMapper, bothMapper);
    }

    @Override
    public R getOrElse(final Function<? super L, ? extends R> orElse) {
      return this.function.apply(null).getOrElse(orElse);
    }

    @Override
    public R getOrElse(final R orElse) {
      return this.function.apply(null).getOrElse(orElse);
    }

    @Override
    public L getLeftOrElse(final Function<? super R, ? extends L> orElse) {
      return this.function.apply(null).getLeftOrElse(orElse);
    }

    @Override
    public L getLeftOrElse(final L orElse) {
      return this.function.apply(null).getLeftOrElse(orElse);
    }
  }
}
